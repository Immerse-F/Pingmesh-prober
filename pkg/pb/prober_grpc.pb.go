// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.2
// source: prober.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ProberAgentIpReport_ProberAgentIpReports_FullMethodName = "/pb.ProberAgentIpReport/ProberAgentIpReports"
)

// ProberAgentIpReportClient is the client API for ProberAgentIpReport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProberAgentIpReportClient interface {
	// Sends Get ProberTargets request
	ProberAgentIpReports(ctx context.Context, in *ProberAgentIpReportRequest, opts ...grpc.CallOption) (*ProberAgentIpReportResponse, error)
}

type proberAgentIpReportClient struct {
	cc grpc.ClientConnInterface
}

func NewProberAgentIpReportClient(cc grpc.ClientConnInterface) ProberAgentIpReportClient {
	return &proberAgentIpReportClient{cc}
}

func (c *proberAgentIpReportClient) ProberAgentIpReports(ctx context.Context, in *ProberAgentIpReportRequest, opts ...grpc.CallOption) (*ProberAgentIpReportResponse, error) {
	out := new(ProberAgentIpReportResponse)
	err := c.cc.Invoke(ctx, ProberAgentIpReport_ProberAgentIpReports_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProberAgentIpReportServer is the server API for ProberAgentIpReport service.
// All implementations must embed UnimplementedProberAgentIpReportServer
// for forward compatibility
type ProberAgentIpReportServer interface {
	// Sends Get ProberTargets request
	ProberAgentIpReports(context.Context, *ProberAgentIpReportRequest) (*ProberAgentIpReportResponse, error)
	mustEmbedUnimplementedProberAgentIpReportServer()
}

// UnimplementedProberAgentIpReportServer must be embedded to have forward compatible implementations.
type UnimplementedProberAgentIpReportServer struct {
}

func (UnimplementedProberAgentIpReportServer) ProberAgentIpReports(context.Context, *ProberAgentIpReportRequest) (*ProberAgentIpReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProberAgentIpReports not implemented")
}
func (UnimplementedProberAgentIpReportServer) mustEmbedUnimplementedProberAgentIpReportServer() {}

// UnsafeProberAgentIpReportServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProberAgentIpReportServer will
// result in compilation errors.
type UnsafeProberAgentIpReportServer interface {
	mustEmbedUnimplementedProberAgentIpReportServer()
}

func RegisterProberAgentIpReportServer(s grpc.ServiceRegistrar, srv ProberAgentIpReportServer) {
	s.RegisterService(&ProberAgentIpReport_ServiceDesc, srv)
}

func _ProberAgentIpReport_ProberAgentIpReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProberAgentIpReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProberAgentIpReportServer).ProberAgentIpReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProberAgentIpReport_ProberAgentIpReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProberAgentIpReportServer).ProberAgentIpReports(ctx, req.(*ProberAgentIpReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProberAgentIpReport_ServiceDesc is the grpc.ServiceDesc for ProberAgentIpReport service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProberAgentIpReport_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProberAgentIpReport",
	HandlerType: (*ProberAgentIpReportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProberAgentIpReports",
			Handler:    _ProberAgentIpReport_ProberAgentIpReports_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prober.proto",
}

const (
	GetProberTarget_GetProberTargets_FullMethodName = "/pb.GetProberTarget/GetProberTargets"
)

// GetProberTargetClient is the client API for GetProberTarget service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GetProberTargetClient interface {
	// Sends Get ProberTargets request
	GetProberTargets(ctx context.Context, in *ProberTargetsGetRequest, opts ...grpc.CallOption) (*ProberTargetsGetResponse, error)
}

type getProberTargetClient struct {
	cc grpc.ClientConnInterface
}

func NewGetProberTargetClient(cc grpc.ClientConnInterface) GetProberTargetClient {
	return &getProberTargetClient{cc}
}

func (c *getProberTargetClient) GetProberTargets(ctx context.Context, in *ProberTargetsGetRequest, opts ...grpc.CallOption) (*ProberTargetsGetResponse, error) {
	out := new(ProberTargetsGetResponse)
	err := c.cc.Invoke(ctx, GetProberTarget_GetProberTargets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetProberTargetServer is the server API for GetProberTarget service.
// All implementations must embed UnimplementedGetProberTargetServer
// for forward compatibility
type GetProberTargetServer interface {
	// Sends Get ProberTargets request
	GetProberTargets(context.Context, *ProberTargetsGetRequest) (*ProberTargetsGetResponse, error)
	mustEmbedUnimplementedGetProberTargetServer()
}

// UnimplementedGetProberTargetServer must be embedded to have forward compatible implementations.
type UnimplementedGetProberTargetServer struct {
}

func (UnimplementedGetProberTargetServer) GetProberTargets(context.Context, *ProberTargetsGetRequest) (*ProberTargetsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProberTargets not implemented")
}
func (UnimplementedGetProberTargetServer) mustEmbedUnimplementedGetProberTargetServer() {}

// UnsafeGetProberTargetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GetProberTargetServer will
// result in compilation errors.
type UnsafeGetProberTargetServer interface {
	mustEmbedUnimplementedGetProberTargetServer()
}

func RegisterGetProberTargetServer(s grpc.ServiceRegistrar, srv GetProberTargetServer) {
	s.RegisterService(&GetProberTarget_ServiceDesc, srv)
}

func _GetProberTarget_GetProberTargets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProberTargetsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetProberTargetServer).GetProberTargets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GetProberTarget_GetProberTargets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetProberTargetServer).GetProberTargets(ctx, req.(*ProberTargetsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GetProberTarget_ServiceDesc is the grpc.ServiceDesc for GetProberTarget service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GetProberTarget_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GetProberTarget",
	HandlerType: (*GetProberTargetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProberTargets",
			Handler:    _GetProberTarget_GetProberTargets_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prober.proto",
}

const (
	PushProberResult_PushProberResults_FullMethodName = "/pb.PushProberResult/PushProberResults"
)

// PushProberResultClient is the client API for PushProberResult service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PushProberResultClient interface {
	// Sends Get ProberTargets request
	PushProberResults(ctx context.Context, in *ProberResultPushRequest, opts ...grpc.CallOption) (*ProberResultPushResponse, error)
}

type pushProberResultClient struct {
	cc grpc.ClientConnInterface
}

func NewPushProberResultClient(cc grpc.ClientConnInterface) PushProberResultClient {
	return &pushProberResultClient{cc}
}

func (c *pushProberResultClient) PushProberResults(ctx context.Context, in *ProberResultPushRequest, opts ...grpc.CallOption) (*ProberResultPushResponse, error) {
	out := new(ProberResultPushResponse)
	err := c.cc.Invoke(ctx, PushProberResult_PushProberResults_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PushProberResultServer is the server API for PushProberResult service.
// All implementations must embed UnimplementedPushProberResultServer
// for forward compatibility
type PushProberResultServer interface {
	// Sends Get ProberTargets request
	PushProberResults(context.Context, *ProberResultPushRequest) (*ProberResultPushResponse, error)
	mustEmbedUnimplementedPushProberResultServer()
}

// UnimplementedPushProberResultServer must be embedded to have forward compatible implementations.
type UnimplementedPushProberResultServer struct {
}

func (UnimplementedPushProberResultServer) PushProberResults(context.Context, *ProberResultPushRequest) (*ProberResultPushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushProberResults not implemented")
}
func (UnimplementedPushProberResultServer) mustEmbedUnimplementedPushProberResultServer() {}

// UnsafePushProberResultServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PushProberResultServer will
// result in compilation errors.
type UnsafePushProberResultServer interface {
	mustEmbedUnimplementedPushProberResultServer()
}

func RegisterPushProberResultServer(s grpc.ServiceRegistrar, srv PushProberResultServer) {
	s.RegisterService(&PushProberResult_ServiceDesc, srv)
}

func _PushProberResult_PushProberResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProberResultPushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushProberResultServer).PushProberResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PushProberResult_PushProberResults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushProberResultServer).PushProberResults(ctx, req.(*ProberResultPushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PushProberResult_ServiceDesc is the grpc.ServiceDesc for PushProberResult service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PushProberResult_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.PushProberResult",
	HandlerType: (*PushProberResultServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushProberResults",
			Handler:    _PushProberResult_PushProberResults_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prober.proto",
}

const (
	VlanService_RefreshVlan_FullMethodName = "/pb.VlanService/RefreshVlan"
)

// VlanServiceClient is the client API for VlanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VlanServiceClient interface {
	RefreshVlan(ctx context.Context, in *RefreshVlanRequest, opts ...grpc.CallOption) (*RefreshVlanResponse, error)
}

type vlanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVlanServiceClient(cc grpc.ClientConnInterface) VlanServiceClient {
	return &vlanServiceClient{cc}
}

func (c *vlanServiceClient) RefreshVlan(ctx context.Context, in *RefreshVlanRequest, opts ...grpc.CallOption) (*RefreshVlanResponse, error) {
	out := new(RefreshVlanResponse)
	err := c.cc.Invoke(ctx, VlanService_RefreshVlan_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VlanServiceServer is the server API for VlanService service.
// All implementations must embed UnimplementedVlanServiceServer
// for forward compatibility
type VlanServiceServer interface {
	RefreshVlan(context.Context, *RefreshVlanRequest) (*RefreshVlanResponse, error)
	mustEmbedUnimplementedVlanServiceServer()
}

// UnimplementedVlanServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVlanServiceServer struct {
}

func (UnimplementedVlanServiceServer) RefreshVlan(context.Context, *RefreshVlanRequest) (*RefreshVlanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshVlan not implemented")
}
func (UnimplementedVlanServiceServer) mustEmbedUnimplementedVlanServiceServer() {}

// UnsafeVlanServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VlanServiceServer will
// result in compilation errors.
type UnsafeVlanServiceServer interface {
	mustEmbedUnimplementedVlanServiceServer()
}

func RegisterVlanServiceServer(s grpc.ServiceRegistrar, srv VlanServiceServer) {
	s.RegisterService(&VlanService_ServiceDesc, srv)
}

func _VlanService_RefreshVlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshVlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VlanServiceServer).RefreshVlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VlanService_RefreshVlan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VlanServiceServer).RefreshVlan(ctx, req.(*RefreshVlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VlanService_ServiceDesc is the grpc.ServiceDesc for VlanService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VlanService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.VlanService",
	HandlerType: (*VlanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVlan",
			Handler:    _VlanService_RefreshVlan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prober.proto",
}

const (
	VlanSwitchNotify_NotifyVlanSwitched_FullMethodName = "/pb.VlanSwitchNotify/NotifyVlanSwitched"
)

// VlanSwitchNotifyClient is the client API for VlanSwitchNotify service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VlanSwitchNotifyClient interface {
	NotifyVlanSwitched(ctx context.Context, in *NotifyVlanSwitchedRequest, opts ...grpc.CallOption) (*NotifyVlanSwitchedResponse, error)
}

type vlanSwitchNotifyClient struct {
	cc grpc.ClientConnInterface
}

func NewVlanSwitchNotifyClient(cc grpc.ClientConnInterface) VlanSwitchNotifyClient {
	return &vlanSwitchNotifyClient{cc}
}

func (c *vlanSwitchNotifyClient) NotifyVlanSwitched(ctx context.Context, in *NotifyVlanSwitchedRequest, opts ...grpc.CallOption) (*NotifyVlanSwitchedResponse, error) {
	out := new(NotifyVlanSwitchedResponse)
	err := c.cc.Invoke(ctx, VlanSwitchNotify_NotifyVlanSwitched_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VlanSwitchNotifyServer is the server API for VlanSwitchNotify service.
// All implementations must embed UnimplementedVlanSwitchNotifyServer
// for forward compatibility
type VlanSwitchNotifyServer interface {
	NotifyVlanSwitched(context.Context, *NotifyVlanSwitchedRequest) (*NotifyVlanSwitchedResponse, error)
	mustEmbedUnimplementedVlanSwitchNotifyServer()
}

// UnimplementedVlanSwitchNotifyServer must be embedded to have forward compatible implementations.
type UnimplementedVlanSwitchNotifyServer struct {
}

func (UnimplementedVlanSwitchNotifyServer) NotifyVlanSwitched(context.Context, *NotifyVlanSwitchedRequest) (*NotifyVlanSwitchedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyVlanSwitched not implemented")
}
func (UnimplementedVlanSwitchNotifyServer) mustEmbedUnimplementedVlanSwitchNotifyServer() {}

// UnsafeVlanSwitchNotifyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VlanSwitchNotifyServer will
// result in compilation errors.
type UnsafeVlanSwitchNotifyServer interface {
	mustEmbedUnimplementedVlanSwitchNotifyServer()
}

func RegisterVlanSwitchNotifyServer(s grpc.ServiceRegistrar, srv VlanSwitchNotifyServer) {
	s.RegisterService(&VlanSwitchNotify_ServiceDesc, srv)
}

func _VlanSwitchNotify_NotifyVlanSwitched_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyVlanSwitchedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VlanSwitchNotifyServer).NotifyVlanSwitched(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VlanSwitchNotify_NotifyVlanSwitched_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VlanSwitchNotifyServer).NotifyVlanSwitched(ctx, req.(*NotifyVlanSwitchedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VlanSwitchNotify_ServiceDesc is the grpc.ServiceDesc for VlanSwitchNotify service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VlanSwitchNotify_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.VlanSwitchNotify",
	HandlerType: (*VlanSwitchNotifyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyVlanSwitched",
			Handler:    _VlanSwitchNotify_NotifyVlanSwitched_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prober.proto",
}
